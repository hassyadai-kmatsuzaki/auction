# データベース設計（改善版 v2.1）実装ガイド

## 📋 目次

1. [改善版の概要](#改善版の概要)
2. [マイグレーション実行手順](#マイグレーション実行手順)
3. [Phase 1（初期実装）とPhase 2（拡張）の違い](#phase-1初期実装とphase-2拡張の違い)
4. [実装例](#実装例)
5. [テスト方法](#テスト方法)
6. [トラブルシューティング](#トラブルシューティング)

---

## 改善版の概要

### 🎯 CTOフィードバックへの対応

| 指摘事項 | 対応内容 | 優先度 |
|---------|---------|--------|
| 出品者・保証金の扱いが不明確 | Phase 1/2で明確化、`is_enabled`フラグ追加 | 🔴 最優先 |
| bidsが状態と履歴を混在 | `bid_participants`（状態）+ `bid_events`（履歴）に分離 | 🔴 高 |
| 価格更新の整合性が曖昧 | `price_events`テーブルで根拠を記録 | 🔴 高 |
| won_itemsの更新ルール不明確 | `shipping_locked_at`追加、ルール明文化 | 🔴 高 |
| 監査ログがない | `audit_logs`テーブル追加 | 🟡 中 |
| 金額の型と丸め規則 | DECIMAL(10,2)維持、丸め規則を明文化 | 🟡 中 |

---

## マイグレーション実行手順

### Step 1: 既存マイグレーションの実行

```bash
# 基本テーブルを作成（既に実行済みの場合はスキップ）
docker exec -it auction-app php artisan migrate
```

### Step 2: 改善版マイグレーションの実行

```bash
# 改善版マイグレーション（8ファイル）を実行
docker exec -it auction-app php artisan migrate

# 実行されるマイグレーション：
# ✅ 2024_01_16_100001_update_sellers_add_is_enabled.php
# ✅ 2024_01_16_100002_update_auction_deposits_add_is_enabled.php
# ✅ 2024_01_16_100003_update_items_seller_id_nullable.php
# ✅ 2024_01_16_100004_create_bid_participants_table.php
# ✅ 2024_01_16_100005_create_bid_events_table.php
# ✅ 2024_01_16_100006_create_price_events_table.php
# ✅ 2024_01_16_100007_update_won_items_add_shipping_locked_at.php
# ✅ 2024_01_16_100008_create_audit_logs_table.php
```

### Step 3: （オプション）従来のbidsテーブルを削除

⚠️ **注意**: 既存データがある場合は、必ず移行してから実行してください。

```bash
# 既存データを bid_events に移行（カスタムコマンドを作成推奨）
docker exec -it auction-app php artisan migrate:bids-to-events

# bidsテーブル削除
docker exec -it auction-app php artisan migrate --path=database/migrations/2024_01_16_100009_drop_bids_table.php
```

### Step 4: 確認

```bash
# テーブル一覧を確認
docker exec -it auction-app php artisan db:table

# 特定テーブルの構造を確認
docker exec -it auction-app php artisan db:show bid_participants
docker exec -it auction-app php artisan db:show bid_events
docker exec -it auction-app php artisan db:show price_events
docker exec -it auction-app php artisan db:show audit_logs
```

---

## Phase 1（初期実装）とPhase 2（拡張）の違い

### Phase 1：ライブオークション特化（初期実装）

```sql
-- 使用するテーブル
✅ users（管理者・参加者）
✅ auctions（オークションイベント）
✅ items（商品） ※seller_id = NULL
✅ item_media（動画・画像）
✅ lanes（レーン）
✅ lane_items（レーン割り当て）
✅ bid_participants（入札参加状態）
✅ bid_events（入札イベント履歴）
✅ price_events（価格変動履歴）
✅ won_items（落札）
✅ announcements（お知らせ）
✅ announcement_reads（既読）
✅ system_settings（設定）
✅ audit_logs（監査ログ）

-- 未使用（将来用）
⏸️ sellers（is_enabled = FALSE）
⏸️ deposits（未使用）
⏸️ auction_deposits（is_enabled = FALSE）
```

**特徴**：
- 管理者が全商品を一括管理
- 出品者の概念なし
- 保証金なし
- シンプルな入札・落札フロー

### Phase 2：マーケットプレイス要素追加（将来拡張）

```sql
-- 有効化
✅ sellers（is_enabled = TRUE）
✅ deposits（使用開始）
✅ auction_deposits（is_enabled = TRUE）
✅ items.seller_id（NOT NULL制約）

-- 追加
✅ seller_settlements（出品者精算）
✅ payouts（振込管理）
```

**特徴**：
- 出品者登録・管理
- 出品者への精算・振込
- 保証金システム
- マーケットプレイス機能

---

## 実装例

### 1. 入札参加（ONボタン押下）

```php
use App\Models\BidParticipant;
use App\Models\BidEvent;
use App\Models\PriceEvent;
use App\Models\Item;
use Illuminate\Support\Facades\DB;

class BidService
{
    public function joinBid($itemId, $userId)
    {
        return DB::transaction(function () use ($itemId, $userId) {
            // 1. 参加状態を記録/更新
            $participant = BidParticipant::updateOrCreate(
                ['item_id' => $itemId, 'user_id' => $userId],
                [
                    'is_active' => true,
                    'activated_at' => now(),
                    'deactivated_at' => null,
                    'ip_address' => request()->ip(),
                    'user_agent' => request()->userAgent(),
                ]
            );
            
            // 2. イベントを記録
            $item = Item::findOrFail($itemId);
            BidEvent::create([
                'item_id' => $itemId,
                'user_id' => $userId,
                'event_type' => 'join',
                'price_at_event' => $item->current_price,
                'ip_address' => request()->ip(),
                'user_agent' => request()->userAgent(),
            ]);
            
            // 3. アクティブ入札者数をカウント
            $activeCount = BidParticipant::where('item_id', $itemId)
                ->where('is_active', true)
                ->count();
            
            // 4. WebSocketで通知
            broadcast(new BidderJoined($item, $activeCount));
            
            return [
                'participant' => $participant,
                'active_count' => $activeCount,
            ];
        });
    }
    
    public function leaveBid($itemId, $userId)
    {
        return DB::transaction(function () use ($itemId, $userId) {
            // 1. 参加状態を更新
            $participant = BidParticipant::where('item_id', $itemId)
                ->where('user_id', $userId)
                ->firstOrFail();
            
            $participant->update([
                'is_active' => false,
                'deactivated_at' => now(),
            ]);
            
            // 2. イベントを記録
            $item = Item::findOrFail($itemId);
            BidEvent::create([
                'item_id' => $itemId,
                'user_id' => $userId,
                'event_type' => 'leave',
                'price_at_event' => $item->current_price,
                'ip_address' => request()->ip(),
                'user_agent' => request()->userAgent(),
            ]);
            
            // 3. アクティブ入札者数をカウント
            $activeCount = BidParticipant::where('item_id', $itemId)
                ->where('is_active', true)
                ->count();
            
            // 4. WebSocketで通知
            broadcast(new BidderLeft($item, $activeCount));
            
            return [
                'participant' => $participant,
                'active_count' => $activeCount,
            ];
        });
    }
}
```

### 2. 価格自動上昇（3秒経過）

```php
class PriceRaiseJob implements ShouldQueue
{
    public function handle()
    {
        DB::transaction(function () {
            // 1. 現在価格を取得（行ロック）
            $item = Item::where('id', $this->itemId)
                ->where('status', 'live')
                ->lockForUpdate()
                ->first();
            
            if (!$item) {
                return;
            }
            
            // 2. アクティブ入札者数を確認
            $activeCount = BidParticipant::where('item_id', $this->itemId)
                ->where('is_active', true)
                ->count();
            
            // 3. 複数人参加中のみ価格上昇
            if ($activeCount >= 2) {
                $oldPrice = $item->current_price;
                $newPrice = $oldPrice + $item->bid_increment;
                
                // 価格変動を記録
                PriceEvent::create([
                    'item_id' => $this->itemId,
                    'old_price' => $oldPrice,
                    'new_price' => $newPrice,
                    'reason' => 'auto_increment',
                    'active_bidder_count' => $activeCount,
                ]);
                
                // 価格を更新
                $item->update(['current_price' => $newPrice]);
                
                // 各参加者にイベント記録
                $participants = BidParticipant::where('item_id', $this->itemId)
                    ->where('is_active', true)
                    ->get();
                
                foreach ($participants as $participant) {
                    BidEvent::create([
                        'item_id' => $this->itemId,
                        'user_id' => $participant->user_id,
                        'event_type' => 'price_accept',
                        'price_at_event' => $newPrice,
                    ]);
                }
                
                // WebSocketで通知
                broadcast(new PriceUpdated($item, $oldPrice, $newPrice, $activeCount));
            }
        });
    }
}
```

### 3. 監査ログの記録

```php
use App\Models\AuditLog;

// ユーザー承認時
AuditLog::create([
    'user_id' => auth()->id(),
    'action' => 'user.approved',
    'auditable_type' => 'User',
    'auditable_id' => $user->id,
    'old_values' => ['status' => 'pending'],
    'new_values' => ['status' => 'approved', 'approved_at' => now()],
    'ip_address' => request()->ip(),
    'user_agent' => request()->userAgent(),
]);

// 入金確認時
AuditLog::create([
    'user_id' => auth()->id(),
    'action' => 'won_item.payment_confirmed',
    'auditable_type' => 'WonItem',
    'auditable_id' => $wonItem->id,
    'old_values' => ['payment_status' => 'paid'],
    'new_values' => [
        'payment_status' => 'confirmed',
        'payment_confirmed_at' => now(),
        'shipping_locked_at' => now(),
    ],
    'ip_address' => request()->ip(),
    'user_agent' => request()->userAgent(),
]);
```

### 4. 配送先更新のバリデーション

```php
class WonItemController extends Controller
{
    public function updateShipping(Request $request, $id)
    {
        $wonItem = WonItem::findOrFail($id);
        
        // 配送先ロックチェック
        if ($wonItem->shipping_locked_at !== null) {
            return response()->json([
                'error' => '入金確認後は配送先を変更できません',
                'locked_at' => $wonItem->shipping_locked_at,
            ], 403);
        }
        
        // バリデーション
        $validated = $request->validate([
            'shipping_postal_code' => 'required|string|max:10',
            'shipping_prefecture' => 'required|string|max:50',
            'shipping_city' => 'required|string|max:100',
            'shipping_address_line1' => 'required|string|max:255',
            'shipping_address_line2' => 'nullable|string|max:255',
            'shipping_name' => 'required|string|max:255',
            'shipping_phone' => 'required|string|max:20',
        ]);
        
        // 更新
        $wonItem->update($validated);
        
        return response()->json([
            'message' => '配送先を更新しました',
            'won_item' => $wonItem,
        ]);
    }
}
```

---

## テスト方法

### 1. 単体テスト

```php
// tests/Unit/BidServiceTest.php
class BidServiceTest extends TestCase
{
    public function test_join_bid_creates_participant_and_event()
    {
        $item = Item::factory()->create(['status' => 'live']);
        $user = User::factory()->create(['status' => 'approved']);
        
        $service = new BidService();
        $result = $service->joinBid($item->id, $user->id);
        
        // 参加状態が記録されているか
        $this->assertDatabaseHas('bid_participants', [
            'item_id' => $item->id,
            'user_id' => $user->id,
            'is_active' => true,
        ]);
        
        // イベントが記録されているか
        $this->assertDatabaseHas('bid_events', [
            'item_id' => $item->id,
            'user_id' => $user->id,
            'event_type' => 'join',
        ]);
        
        // アクティブ入札者数が正しいか
        $this->assertEquals(1, $result['active_count']);
    }
    
    public function test_price_raises_with_multiple_active_bidders()
    {
        $item = Item::factory()->create([
            'status' => 'live',
            'current_price' => 1000,
            'bid_increment' => 100,
        ]);
        
        // 2人が入札参加
        BidParticipant::factory()->create(['item_id' => $item->id, 'is_active' => true]);
        BidParticipant::factory()->create(['item_id' => $item->id, 'is_active' => true]);
        
        // 価格上昇Job実行
        $job = new PriceRaiseJob($item->id);
        $job->handle();
        
        // 価格が上昇しているか
        $this->assertDatabaseHas('items', [
            'id' => $item->id,
            'current_price' => 1100,
        ]);
        
        // 価格変動イベントが記録されているか
        $this->assertDatabaseHas('price_events', [
            'item_id' => $item->id,
            'old_price' => 1000,
            'new_price' => 1100,
            'reason' => 'auto_increment',
            'active_bidder_count' => 2,
        ]);
    }
}
```

### 2. 統合テスト

```php
// tests/Feature/AuctionFlowTest.php
class AuctionFlowTest extends TestCase
{
    public function test_full_auction_flow()
    {
        // 1. オークション開始
        $auction = Auction::factory()->create(['status' => 'live']);
        $item = Item::factory()->create([
            'auction_id' => $auction->id,
            'status' => 'live',
            'current_price' => 1000,
        ]);
        
        // 2. ユーザーが入札参加
        $user1 = User::factory()->create(['status' => 'approved']);
        $user2 = User::factory()->create(['status' => 'approved']);
        
        $this->actingAs($user1)->postJson("/api/bids/{$item->id}/join");
        $this->actingAs($user2)->postJson("/api/bids/{$item->id}/join");
        
        // 3. 価格が自動上昇
        $job = new PriceRaiseJob($item->id);
        $job->handle();
        
        $item->refresh();
        $this->assertEquals(1100, $item->current_price);
        
        // 4. user2が離脱
        $this->actingAs($user2)->postJson("/api/bids/{$item->id}/leave");
        
        // 5. 落札確定
        $wonItem = WonItem::create([
            'item_id' => $item->id,
            'winner_id' => $user1->id,
            'winning_price' => $item->current_price,
            'quantity' => $item->quantity,
            'total_amount' => $item->current_price * $item->quantity,
        ]);
        
        // 6. 監査ログが記録されているか
        $this->assertDatabaseHas('audit_logs', [
            'action' => 'won_item.created',
            'auditable_type' => 'WonItem',
            'auditable_id' => $wonItem->id,
        ]);
    }
}
```

---

## トラブルシューティング

### Q1: `items.seller_id`の外部キー制約エラー

**エラー**:
```
SQLSTATE[23000]: Integrity constraint violation: Cannot add or update a child row
```

**解決方法**:
```bash
# マイグレーションを再実行
php artisan migrate:rollback --step=1
php artisan migrate
```

### Q2: bidsテーブルのデータ移行方法

**手順**:
```bash
# カスタムコマンドを作成
php artisan make:command MigrateBidsToEvents

# コマンド内容
public function handle()
{
    $this->info('bids → bid_events へのデータ移行を開始します...');
    
    Bid::chunk(100, function ($bids) {
        foreach ($bids as $bid) {
            BidEvent::create([
                'item_id' => $bid->item_id,
                'user_id' => $bid->bidder_id,
                'event_type' => $bid->is_active ? 'join' : 'leave',
                'price_at_event' => $bid->bid_price,
                'ip_address' => $bid->ip_address,
                'user_agent' => $bid->user_agent,
                'created_at' => $bid->created_at,
            ]);
        }
    });
    
    $this->info('移行完了！');
}

# 実行
php artisan migrate:bids-to-events
```

### Q3: Phase 2への移行方法

**手順**:
```sql
-- 1. 出品者機能を有効化
UPDATE sellers SET is_enabled = TRUE;

-- 2. 保証金機能を有効化
UPDATE auction_deposits SET is_enabled = TRUE WHERE auction_id = ?;

-- 3. 既存商品にseller_idを設定
UPDATE items SET seller_id = ? WHERE auction_id = ?;

-- 4. アプリケーション側でseller_id必須に変更
// Validation rules
'seller_id' => 'required|exists:sellers,id',
```

---

**改善版v2.1の実装ガイドが完成しました！** 🎉

このガイドに従って実装を進めてください。
